using System;
using System.Linq;
using System.Collections;
using System.ComponentModel.Design;
using System.Diagnostics;
using System.Drawing;
using System.Dynamic;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Xml;
using System.Xml.Linq;
using Microsoft.VisualBasic;
using static System.Net.Mime.MediaTypeNames;
using static H;
using System.ComponentModel.DataAnnotations;
using System.Collections.Generic;
using System.Security.AccessControl;

class H
{
    class edge
    {
        public int point1;
        public int point2;
        public int c;
        public int f = 0;
    }
    static int[,] create_mas()
    {
        int[,] mas = new int[5, 5];

        mas[0, 0] = 0;
        mas[0, 1] = 1;
        mas[0, 2] = 1;
        mas[0, 3] = 0;

        mas[1, 0] = 0;
        mas[1, 1] = 0;
        mas[1, 2] = 1;
        mas[1, 3] = 1;

        mas[2, 0] = 0;
        mas[2, 1] = 0;
        mas[2, 2] = 0;
        mas[2, 3] = 1;

        mas[3, 0] = 0;
        mas[3, 1] = 0;
        mas[3, 2] = 0;
        mas[3, 3] = 0;

        return mas;
    }
    static void Main()
    {
        int[,] mas = create_mas();
        int n = mas.GetUpperBound(0) + 1;

        int[] points = new int[5];
        for (int i=0; i<5; i++)
        {
            points[i] = i;
        }

        edge[] edges = new edge[5];

        edges[0] = new edge { point1 = 0, point2 = 1, c = 1000 };
        edges[1] = new edge { point1 = 0, point2 = 2, c = 1000 };
        edges[2] = new edge { point1 = 1, point2 = 2, c = 1 };
        edges[3] = new edge { point1 = 1, point2 = 3, c = 1000 };
        edges[4] = new edge { point1 = 2, point2 = 3, c = 1000 };

        edge back=new edge { };
        int q = 0;
        for (; ; )
        {
            int[] visited = new int[5];
            int q1 = Ford_F(points[0], int.MaxValue, ref visited, edges, ref back);
            if (q1 == 0)
            {
                break;
            }
            q += q1;
        }
        Console.WriteLine("Максимальный поток - "+q);
    }

    static int Ford_F(int u, int c, ref int []visited, edge []edges, ref edge back)
    {
        if (u == 3)
            return c;
        visited[u] = 1;
        var q = from i in edges
                where i.point1 == u 
                select i;
        foreach (var edge in q)
        {
            edge uv = edge;
            if ((visited[uv.point2]!=1)&&(uv.f<uv.c))
            {
                back = uv;
                int delta = Ford_F(uv.point2, min(c, uv.c - uv.f), ref visited, edges, ref back);
                if (delta>0)
                {
                    uv.f += delta;
                    WriteBack(back, delta);
                    return delta;
                }
            }
        }
        return 0;
    }
    static void WriteBack(edge a, int b)
    {
        if (a!=null)
        {
            a.f -= b;
        }    
    }
    static int min(int a, int b)
    {
        if (a<b)
        {
            return a;
        }
        return b;
    }
}
